<h1 style="text-align:center;">SPN加密与差分密码分析</h1>

<p style="text-align: center;">学号： 姓名： 专业：</p>

实验中所出现的代码详见：https://github.com/DrNbnonono/Cryptography-Homework/upload/main/Chapter3

[TOC]

## 1. SPN差分分析简介

### 1.1 **分析思想：**

差分密码分析通过分析**固定输入差分**对应的**输出差分分布**来恢复密钥。与线性分析不同，它关注的是**明密文对的差异传播**而非线性关系。

> **关键概念**：
>
> - **输入差分**：ΔX = X ⊕ X*
>
> - **输出差分**：ΔY = Y ⊕ Y*
> - **差分特征**：ΔX → ΔY 的传播路径

### 1.2 **基础概念：**

**(1) 差分 (Difference)**

- **定义**：两个二进制串的异或 (XOR) 结果，记作 $\Delta X = X \oplus X^*$。
- **在SPN中**：
  - 输入差分 $\Delta X$：明文对的异或
  - 输出差分 $\Delta Y$：密文对的异或
  - S盒差分 $\Delta S$：S盒输入/输出的异或

**(2) 差分分布表 (Difference Distribution Table, DDT)**

- **定义**：记录S盒所有可能的输入差分 $\Delta X$ 和输出差分 $\Delta Y$ 的组合及其出现频率的表格。
- **公式**：
  $$
  N_D(Δx, Δy) = {(x,x*) | x⊕x*=Δx, π_S(x)⊕π_S(x*)=Δy}
  $$
- **扩散率 (Probability)**：
  $$
  R_p(Δx,Δy) = N_D(Δx,Δy)/2^m
  $$

**(3) 差分链 (Differential Characteristic)**

- **定义**：多轮差分传播的路径，由每轮的输入差分 $\Delta X_r$ 和输出差分 $\Delta Y_r$ 串联而成。
- **总扩散率**：各轮扩散率的乘积（假设轮间独立）。

**(4)正确对**

- 在差分攻击中，**正确对**是指满足以下条件的4元组 $(x, x^*, y, y^*)$​：
  $$
  \begin{cases}
  (u_4)' = (u_3)' = 0000 \\
  y_1 = y_1^* \\
  y_3 = y_3^*
  \end{cases}
  $$

- 正确对可以有效地提升分析的效率，对于攻击进行优化，并且对分析设定一定的阈值

### 1.3 攻击算法步骤（已知差分链）

1. 算法输入与初始化：

   **输入**：
     - 明密文四元组集合 $$T = \{(x, x^*, y, y^*)\}$$，其中 $$x \oplus x^* = \Delta X$$（固定输入差分）

   **初始化**：

   ```python
   for (L₁, L₂) ← (0,0) to (F,F):
       Count[L₁, L₂] ← 0  # 初始化所有候选密钥计数器

2. 过滤正确对

   对每个四元组 $$(x, x^*, y, y^*) \in T$$，检查是否满足：$$(y_{<1>}^4 = (y_{<1>}^4)^*) \ \text{AND} \ (y_{<3>}^4 = (y_{<3>}^4)^*)$$

   > **数学意义**：  
   > 对应最后一轮S盒 $$S_1^4$$ 和 $$S_3^4$$ 的输入差分为0（即输出差分仅由 $$S_2^4$$ 和 $$S_4^4$$ 贡献）

3. 部分解密密文：计算最后一轮两个活动S盒（$$S_2^4$$ 和 $$S_4^4$$）的输入：
   $$
   \begin{cases}
   v_{<2>}^4 = L₁ \oplus y_{<2>}^4 \\
   v_{<4>}^4 = L₂ \oplus y_{<4>}^4 \\
   (v_{<2>}^4)^* = L₁ \oplus (y_{<2>}^4)^* \\
   (v_{<4>}^4)^* = L₂ \oplus (y_{<4>}^4)^*
   \end{cases}
   $$

4. 逆S盒运算：通过S盒逆置换得到中间状态：
   $$
   \begin{cases}
   u_{<2>}^4 = \pi_S^{-1}(v_{<2>}^4) \\
   u_{<4>}^4 = \pi_S^{-1}(v_{<4>}^4) \\
   (u_{<2>}^4)^* = \pi_S^{-1}((v_{<2>}^4)^*) \\
   (u_{<4>}^4)^* = \pi_S^{-1}((v_{<4>}^4)^*)
   \end{cases}
   $$

5. 计算中间状态差分
   $$
   \begin{cases}
   (u_{<2>}^4)' = u_{<2>}^4 \oplus (u_{<2>}^4)^* \\
   (u_{<4>}^4)' = u_{<4>}^4 \oplus (u_{<4>}^4)^*
   \end{cases}
   $$

6. 验证差分特征：检查是否匹配预期差分（以课本中为例）：
   $$
   (u_{<2>}^4)' = 0110 \ \text{AND} \ (u_{<4>}^4)' = 0110
   $$
   若成立，则计数器加1：
   $$
   \text{Count}[L₁, L₂] \leftarrow \text{Count}[L₁, L₂] + 1
   $$

7. 确定密钥

   遍历所有候选密钥后，选择计数器值最大的密钥：$$\text{maxkey} = \underset{(L₁,L₂)}{\arg\max} \ \text{Count}[L₁, L₂]$$​

### 1.4 数据量要求

$$
T \approx c \cdot \epsilon^{-1} \quad (\text{例中 } \epsilon^{-1} \approx 38, c \approx 2)
$$

## 2. 获取差分分布表

- 目标：计算S盒的差分分布表

- 代码实现(diff_form.py)

  ```python
  def calculate_ddt(s_box):
      ddt = [[0] * 16 for _ in range(16)] 
      for x in range(16): #遍历16种 x
          for delta_x in range(16):
              x_star = x ^ delta_x 
              delta_y = s_box[x] ^ s_box[x_star]
              ddt[delta_x][delta_y] += 1  #每有一个出现则加1
      return ddt
  
  # 示例：计算S_BOX的DDT
  ddt = calculate_ddt(S_BOX)
  for delta_x in range(16):
      print(f"ΔX={delta_x:04b}: {ddt[delta_x]}")
  ```

对于给定的S盒构建差分分布表，得到下面的内容，与课本中所给出的一致，相应的python代码详见链接

```bash
      0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15 
-------------------------------------------------------------------
 0 |  16   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0
 1 |   0   0   0   2   0   0   0   2   0   2   4   0   4   2   0   0
 2 |   0   0   0   2   0   6   2   2   0   2   0   0   0   0   2   0
 3 |   0   0   2   0   2   0   0   0   0   4   2   0   2   0   0   4
 4 |   0   0   0   2   0   0   6   0   0   2   0   4   2   0   0   0
 5 |   0   4   0   0   0   2   2   0   0   0   4   0   2   0   0   2
 6 |   0   0   0   4   0   4   0   0   0   0   0   0   2   2   2   2
 7 |   0   0   2   2   2   0   2   0   0   2   2   0   0   0   0   4
 8 |   0   0   0   0   0   0   2   2   0   0   0   4   0   4   2   2
 9 |   0   2   0   0   2   0   0   4   2   0   2   2   2   0   0   0
10 |   0   2   2   0   0   0   0   0   6   0   0   2   0   0   4   0
11 |   0   0   8   0   0   2   0   2   0   0   0   0   0   2   0   2
12 |   0   2   0   0   2   2   2   0   0   0   0   2   0   6   0   0
13 |   0   4   0   0   0   0   0   4   2   0   2   0   2   0   2   0
14 |   0   0   2   4   2   0   0   0   6   0   0   0   0   0   2   0
15 |   0   2   0   0   6   0   0   0   0   4   0   2   0   0   2   0
```

## 3. 构建差分链

- 目标：选择高概率的差分路径，覆盖多轮加密
- 数中已经给出一条差分链用于分析 part2 与 part4 的密钥，还需要构造分析 part1 与 part3 的差分链
- 方法：
  1. 从差分分布表中选择高扩散率的(Δ*X*,Δ*Y*)
  2. 通过P盒将输出差分 Δ*Y* 映射到下一轮的输入差分。

- 核心代码(diff_chain.py)：

  ```python
  import numpy as np
  # 给定的S盒和P盒
  # 计算差分分布表
  def calculate_ddt(s_box):
      return ddt
  # 应用P盒置换（处理16位差分）
  def apply_p_box(delta_y_16bit, p_box):
      # 应用P盒置换
      # 返回16位置换后的差分
      return int(permuted_str, 2)
  # 计算16位差分通过S盒的概率
  def calculate_s_box_probability(delta_x_16bit, delta_y_16bit, ddt):
  # 生成差分链
  def generate_differential_chain(initial_delta_x, ddt, s_box, p_box, rounds=3):
      print(f"\n生成差分链 (初始 ΔX = {format_binary(initial_delta_x)}):")
      for r in range(rounds):
          # 计算每个S盒的可能输出差分
          possible_outputs = []
          for i in range(4):    
          # 检查是否所有S盒都有可能的输出差分    
          # 选择每个S盒概率最高的输出差分
          best_delta_y_nibbles = []
          counts = []
          for outputs in possible_outputs:
              best_y, count = max(outputs, key=lambda x: x[1])
              best_delta_y_nibbles.append(best_y)
              counts.append(count)
  
          # 通过P盒计算下一轮输入差分
          next_delta_x = apply_p_box(best_delta_y, p_box)
          print(f"  经P盒置换后下一轮ΔX: {format_binary(next_delta_x)}")
          print("-"*70)
          
          current_delta = next_delta_x
      
      print(f"总概率: {total_prob:.6f}")
      return chain
  ```

1. 对课本中出现的差分链进行验证，输出如下，与课本中的结果一致：

   ```bash
   请输入初始差分ΔX (16位二进制，如0000 1101 0000 0000): 0000 1011 0000 0000
   
   生成差分链 (初始 ΔX = 0000 1011 0000 0000):
   ----------------------------------------------------------------------
   第1轮:
     S盒输入差分 ΔX: 0000 1011 0000 0000
     S盒输出差分 ΔY: 0000 0010 0000 0000
     各S盒出现次数: y' = 0 : 16次, y' = 2 : 8次, y' = 0 : 16次, y' = 0 : 16次
     概率: 0.500000
     经P盒置换后下一轮ΔX: 0000 0000 0100 0000
   ----------------------------------------------------------------------
   第2轮:
     S盒输入差分 ΔX: 0000 0000 0100 0000
     S盒输出差分 ΔY: 0000 0000 0110 0000
     各S盒出现次数: y' = 0 : 16次, y' = 0 : 16次, y' = 6 : 6次, y' = 0 : 16次
     概率: 0.375000
     经P盒置换后下一轮ΔX: 0000 0010 0010 0000
   ----------------------------------------------------------------------
   第3轮:
     S盒输入差分 ΔX: 0000 0010 0010 0000
     S盒输出差分 ΔY: 0000 0101 0101 0000
     各S盒出现次数: y' = 0 : 16次, y' = 5 : 6次, y' = 5 : 6次, y' = 0 : 16次
     概率: 0.140625
     经P盒置换后下一轮ΔX: 0000 0110 0000 0110
   ----------------------------------------------------------------------
   总概率: 0.026367
   
   差分链总结:
   轮次 | ΔX (输入) | ΔY (输出) | 概率
   ----------------------------------------------------------------------
    1   | 0000 1011 0000 0000 | 0000 0010 0000 0000 | 0.500000
    2   | 0000 0000 0100 0000 | 0000 0000 0110 0000 | 0.375000
    3   | 0000 0010 0010 0000 | 0000 0101 0101 0000 | 0.140625
   ```

2. 从差分分布表中选择高扩散率的(Δ*X*,Δ*Y*)，不断进行尝试，直到恰好覆盖 第1，第3个S盒的输出。经过不懈的努力与尝试，最终得到了一个符合条件的差分链

   ```bash
   请输入初始差分ΔX (16位二进制，如0000 1101 0000 0000): 0000 0101 0000 0000
   
   生成差分链 (初始 ΔX = 0000 0101 0000 0000):
   ----------------------------------------------------------------------
   第1轮:
     S盒输入差分 ΔX: 0000 0101 0000 0000
     S盒输出差分 ΔY: 0000 0001 0000 0000
     各S盒出现次数: y' = 0 : 16次, y' = 1 : 4次, y' = 0 : 16次, y' = 0 : 16次
     概率: 0.250000
     经P盒置换后下一轮ΔX: 0000 0000 0000 0100
   ----------------------------------------------------------------------
   第2轮:
     S盒输入差分 ΔX: 0000 0000 0000 0100
     S盒输出差分 ΔY: 0000 0000 0000 0110
     各S盒出现次数: y' = 0 : 16次, y' = 0 : 16次, y' = 0 : 16次, y' = 6 : 6次
     概率: 0.375000
     经P盒置换后下一轮ΔX: 0000 0001 0001 0000
   ----------------------------------------------------------------------
   第3轮:
     S盒输入差分 ΔX: 0000 0001 0001 0000
     S盒输出差分 ΔY: 0000 1010 1010 0000
     各S盒出现次数: y' = 0 : 16次, y' = A : 4次, y' = A : 4次, y' = 0 : 16次
     概率: 0.062500
     经P盒置换后下一轮ΔX: 0110 0000 0110 0000
   ----------------------------------------------------------------------
   总概率: 0.005859
   ```
   
   $$
   R_p(\text{链}) = \prod_{r} R_p(a'_r, b'_r) = \frac{1}{4} \times \frac{3}{8} \times \frac{1}{4}  \times \frac{1}{4} = \frac{3}{512}
   $$

## 4. 得到正确对

- 目标：构造符合要求的输入，通过加密后的 y，y* 筛选符合条件的输入对

  1. **获取足够多的符合输入的差分的数据**，存储进SCV文件中，用于后续的分析，部分代码实现如下，基本与SPN加密无异，其中控制了生成的数据个数，代码如下(SPN.py)：

     ```python
     import csv
     from itertools import product
     S_BOX = {}
     P_BOX = {}
     def substitute(input_bits, s_box):
         """S盒替换函数"""
     def permute(input_bits, p_box):
         """P盒置换函数"""
     def key_schedule(key, Nr):
         """密钥生成"""
     def spn_encrypt(plaintext, key, Nr=4):
         """加密算法"""
     def generate_diff_pairs(x_diff, key, output_filename, sample_size=None):
         """
         生成满足x ⊕ x* = x_diff的明密文对
         """
         # 计算x_diff的整数值
         x_diff_int = int(x_diff, 2)
         # csv文件的内容
         with open(output_filename, 'w', newline='') as csvfile:
             writer = csv.writer(csvfile)
             writer.writerow(['x', 'x*', 'y', 'y*', 'y_diff'])
             # 如果sample_size为None，生成所有可能对(注意这会很大)
             if sample_size is None:
             else:
                 # 随机采样
                 print(f"生成{sample_size}个随机明密文对...")  
                 # 打印进度
                 if count % 1000 == 0:
                     print(f"已生成{count}对...")
         
         print(f"成功生成{count}对明密文对，保存到{output_filename}")
     ```
  
     - 课本中出现的差分链：
  
       - 经过简单的测试，300条数据最终过滤后会得到17条有用的数据，这里采取获取所有符合条件的明文对，共65536条数据：
  
         ```bash
         x,x*,y,y*,y_diff
         0000000000000000,0000101100000000,1001001001111000,1001010111010111,0000011110101111
         0000000000000001,0000101100000001,1001100001111110,1001010111011001,0000110110100111
         0000000000000010,0000101100000010,0100010010010011,0100001111010010,0000011101000001
         ```
  
     - 上述得到的另一个差分链
  
       - 依然采取生成65536条数据对，部分数据如下：
       
         <img src="D:\大二下事务\密码学基础\作业\Capter3-差分攻击\assets\image-20250406101534166.png" alt="image-20250406101534166"  />
  
  2. **对得到的符合输入的差分数据进行过滤**，存储进CSV文件，实现代码如下(data_filiter.py)：
  
     ```python
     import csv
     
     def filter_pairs(input_filename, output_filename, parts_to_match):
         """
         过滤明密文对，保留指定部分相同的y和y*
         :param parts_to_match: 需要匹配的部分索引列表，从0开始
         """
         matched_count = 0
         with open(input_filename, 'r') as infile, open(output_filename, 'w', newline='') as outfile:
            #读取csv文件
             for row in reader:
                 y = row['y']
                 y_star = row['y*']
                 # 检查指定部分是否相同
                 match = True
                 for part in parts_to_match:
                     start = part * 4
                     end = start + 4
                     if y[start:end] != y_star[start:end]:
                         match = False
                         break
                 if match:
                     writer.writerow([row['x'], row['x*'], y, y_star, row['y_diff']])
                     matched_count += 1
     if __name__ == "__main__":
         # 过滤第1和第3部分相同的y和y* (索引从0开始)
         filter_pairs("test.csv", "filtered_pairs.csv", parts_to_match=[0, 2])
         # 对这部分进行修改即可得到第2和第4部分的数据
     ```
  
     - 过滤 2、4部分差分链
  
     - 对每个四元组 $$(x, x^*, y, y^*) \in T$$，检查是否满足：$$(y_{<1>}^4 = (y_{<1>}^4)^*) \ \text{AND} \ (y_{<3>}^4 = (y_{<3>}^4)^*)$$
  
       ```bash
       过滤后保留的数据个数: 4370
       部分数据如下：
       x,x*,y,y*,y_diff
       0000000000010110,0000101100010110,1000101111100101,1000010011101000,0000111100001101
       0000000000011001,0000101100011001,1000011000110101,1000010100111000,0000001100001101
       0000000000011011,0000101100011011,1111001100001000,1111100100000100,0000101000001100
       0000000000011100,0000101100011100,1111100000011000,1111110000010100,0000010000001100
       ```
  
     - 过滤 1、3部分差分链
  
     - 对每个四元组 $$(x, x^*, y, y^*) \in T$$，检查是否满足：$$(y_{<2>}^4 = (y_{<2>}^4)^*) \ \text{AND} \ (y_{<4>}^4 = (y_{<4>}^4)^*)$$
  
       ```bash
       过滤后保留的数据个数: 2044
       ```
       
       ![image-20250406101709056](D:\大二下事务\密码学基础\作业\Capter3-差分攻击\assets\image-20250406101709056.png)
  

## 5. 部分解密与差分验证

- 目标：部分解密密文，并通过S盒的逆运算，与先前得到的差分链进行比较，统计出所有可能的256对密钥组合的出现频率

- 代码实现(part_key.py)：

  ```python
  import csv
  import numpy as np
  # S盒定义
  S_BOX = {}
  # 计算逆S盒
  INV_S_BOX = {v: k for k, v in S_BOX.items()}
  def partial_decrypt_and_verify(input_filename, s_box_inv, part1_idx, part2_idx, expected_diff1, expected_diff2):
      """
      部分解密与差分验证
      参数:
      input_filename - 包含密文对的CSV文件
      s_box_inv - 逆S盒
      part1_idx - 第一个要破解的部分索引 (0-3)
      part2_idx - 第二个要破解的部分索引 (0-3)
      expected_diff1 - 第一个部分期望的差分值
      expected_diff2 - 第二个部分期望的差分值
      返回:
      16x16的计数矩阵
      """
      with open(input_filename, 'r') as csvfile:
          # csv文件处理  
              # 尝试所有可能的4位密钥组合
              for l1 in range(16):
                  for l2 in range(16):
                      # 部分解密
                      v1 = l1 ^ y_part1
                      v2 = l2 ^ y_part2
                      u1 = s_box_inv[v1]
                      u2 = s_box_inv[v2]
                      
                      v1_star = l1 ^ y_star_part1
                      v2_star = l2 ^ y_star_part2
                      u1_star = s_box_inv[v1_star]
                      u2_star = s_box_inv[v2_star]
                      
                      # 计算差分
                      delta_u1 = u1 ^ u1_star
                      delta_u2 = u2 ^ u2_star
                      
                      # 检查是否符合预期差分
                      if delta_u1 == expected_diff1 and delta_u2 == expected_diff2:
                          count_matrix[l1, l2] += 1
      return count_matrix
  ```

  1. 验证第 2 部分和第 4 部分的密钥

     验证差分特征：检查是否匹配预期差分（以课本中为例）：
     $$
     (u_{<2>}^4)' = 0110 \ \text{AND} \ (u_{<4>}^4)' = 0110
     $$
     若成立，则计数器加1：
     $$
     \text{Count}[L₁, L₂] \leftarrow \text{Count}[L₁, L₂] +
     $$
  控制台输出如下：
     
     ```bash
     选择要破解的密钥部分 (0-3):
     0 - 第一部分 (位 0-3)
     1 - 第二部分 (位 4-7)
     2 - 第三部分 (位 8-11)
     3 - 第四部分 (位 12-15)
     请选择第一个部分 (默认: 1): 1
     请选择第二个部分 (默认: 3): 3
     输入期望的差分值 (十六进制, 0-F):
     第2部分期望差分 (默认: 6): 6
     第4部分期望差分 (默认: 6): 6
     
     密钥组合计数矩阵:
          0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
      0:  38  66  56  62   0   8   0   0 118 120 220  10 128 112  16 426
      1:  56  70  58  56   0   4   0   0 122 118 226  10 134 118  12 448
      2:   0   8   0   6   0   4   0   0   4  10   0  10  18   0  16   0
      3:  96 116 112 110   0   0   0   0 228 218 446   0 224 228   0 874
      4:  72  86  74  80  14   0  14   0 118 108 226   0 120 156  12 448
      5:  44  92  54  84   0  24   0   0 134 130 220  20 160 120  48 426
      6: 180 240 224 228   0   0   0   0 450 422 872   0 422 450   0 1744
      7:   0  34   0  28   0  12   0   0  12  16   0  16  40  10  44   0
      8:  36  96  28  76  12  20  12   0  94  64 128  10  98 106  48 236
      9:  44  38  38  34   8   0   8   0  48  50  98   0  56  66   0 212
      A:  22  70  40  64  12   8  12   0  60  64 110   6  78  78  24 224
      B:  34  32  46  46   6   0   6   0  64  54 118   0  54  78   0 250
      C:   4  16   4   6   0   4   0   0   4  12   2  10  28   0  12  14
      D:  10  16   8  12  12   4  12   0  12   4  12   0  10  24   0  12
      E:   6   0   6   4   0   0   0   0   8   6  14   0   8  10   0  26
      F:  10  12   8  12  12   0  12   0   0   0   0   0   2  16   0   0
     
     总数据对数量: 4370
     最高计数: 1744
     最高计数频率: 0.399085 (1744/4370)
     最可能的密钥组合:
     L2=6, L4=F
     ```

  2. 验证第 2 部分和第 4 部分的密钥

     验证差分特征：检查是否匹配预期差分（最后一轮经P盒置换后下一轮ΔX: 0110 0000 0110 0000）：
     $$
     (u_{<1>}^4)' = 0110 \ \text{AND} \ (u_{<3>}^4)' = 0110
     $$
     若成立，则计数器加1：
     $$
     \text{Count}[L₁, L₂] \leftarrow \text{Count}[L₁, L₂] + 1
     $$

     控制台输出如下：
     
     ```bash
     选择要破解的密钥部分 (0-3):
     0 - 第一部分 (位 0-3)
     1 - 第二部分 (位 4-7)
     2 - 第三部分 (位 8-11)
     3 - 第四部分 (位 12-15)
     请选择第一个部分 (默认: 1): 0
     请选择第二个部分 (默认: 3): 2
     
     输入期望的差分值 (十六进制, 0-F):
     第1部分期望差分 (默认: 6): 6
     第3部分期望差分 (默认: 6): 6
     
     密钥组合计数矩阵:
          0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
      0:  18  26   0  70  20  18  42   0   4   6   6   4  16   8  16  14
      1:  22  30  12  58  16  20  48   0  12  20   8  28  22  28  36  20
      2:  16  22   0  48  18  12  32   0   8   8   8  10  20  18  14   6
      3:  26  34   4  46  18  18  40   0   8  16   8  12  18  36  12  12
      4:   0   6   4   0   0   4  10   0  12  16   8  22  18  10  18   8
      5:   2   0   0   0   0   0   8   0   2   6   2   2   2   2   2   0
      6:   2   6   4   0   0   4  12   0   8  12   8  12  12   8   8   8
      7:  10   0   0   0   2   8   2   0   8  26   6  36  24  18  28   4
      8:  72  88   0 226  88  72 164   0   4   2   0   2  12  44  10   4
      9:   0   0   0   0   6   0   0   0   0   6   0   0   0   0   0   0
      A:  44  38   0 110  40  34  72   0   0   2   0   0  10  26   8   4
      B:  38  50   0 116  56  46  88   0   6  22   4  26  18  32  18   4
      C:   6   8   0   0   6   2   0   0   0   8   0   4   2  14   2   0
      D: 130 156   0 448 156 130 286   0   0   0   0   0  32  62  38  30
      E:  52  58   0 116  60  38  92   0   0  14   0   0   6  44   0   0
      F:  34  54   8 110  38  34  76   0  12   0  10   6  20  34  18  14
     
     总数据对数量: 2044
     最高计数: 448
     最高计数频率: 0.219178 (448/2044)
     最可能的密钥组合:
     L1=D, L3=3
     ```

## 6. 确定正确密钥

本次SPN的差分分析攻击，所使用的加密密钥为：0011 1010 1001 0100 1101 0110 0011 1111

其中第五轮加密的密钥为：1101 0110 0011 1111

1. 确定 part2 和 part4 的密钥

   ```
   总数据对数量: 4370
   最高计数: 1744
   最高计数频率: 0.399085 (1744/4370)
   最可能的密钥组合:L2=6, L4=F
   ```

   6 = 0110~2~ ，F = 1111~2~ 

   结果符合第五轮所用到的加密的密钥，成功破解！！！

2. 确定 part1 和 part3 的密钥

   ```
   总数据对数量: 2044
   最高计数: 448
   最高计数频率: 0.219178 (448/2044)
   最可能的密钥组合:L1=D, L3=3
   ```
   
   D = 1101~2~ ，3 = 0011~2~ 
   
   结果符合第五轮所用到的加密的密钥，成功破解！！！

最后成功得到所有的第五轮加密后的密文！



